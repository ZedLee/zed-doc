# 大话分布式服务

## 1. 渣男的故事 -- 用一个段子介绍分布式服务的基本概念

高可用：渣男没有感情，他的目标是当一个优质的中央空调，尽量俘获更多小姐姐的芳心。
所以7 * 24小时都能秒回微信。

数据一致性： 渣男和女友有一共同好友，渣男为了跟这个好友一起开黑打游戏，骗女朋友说晚上要加班。
那么此时最重要的是什么呢，统一口径，否则跪一顿搓衣板怕是免不了。

负载均衡：分布式系统里面期望多个有同样职能的节点能均分压力，渣男也是，一天跟三个女朋友约会，那是身心俱疲。
所以渣男也期望一周每日两天，降低自身压力。

熔断：我们刚刚才谈完负载均衡，现在就有某女友想占用渣男两天的时间，那可怎么行，女友B怎么办。
于是渣男想出一个绝妙的方法，晚饭吃完就说肚子疼，得要赶紧回家对付一下，把女友A的超时请求熔断了，才能正常跟女友B约会。

异构性：分布式系统由于基于不同网络、不同的操作系统、不同的软件实现的软件体系，必须要考虑一种通用的服务集成和交互方式来屏蔽异构系统之间的差异。
就像渣男的女友A喜欢发短信，女友B喜欢打电话，女友C喜欢视频。巧了，微信同时集成了这三种通讯功能，于是渣男就怂恿三个女友都安装了微信。



## 2. 分布式系统的目标

### 2.1 容错性
错误发生时，系统能够继续工作的能力

故障类型	说明
崩溃性故障	服务器停机，但是在停机之前工作正常
遗漏性故障	服务期不能响应到来的消息。包括不能接受、不能发送
定时故障	服务器的响应在指定时间间隔之外
响应故障	服务期的响应不正确。包括响应的值错误、偏离了正确的控制流
随意性故障	服务器可能在随意的时间产生随意的响应

容错方案
如果系统是容错的，那么它能做的最好的事情就是对其他进程隐藏故障的发生。由于故障无法避免，我们只能依靠冗余来掩盖故障，包括：

信息冗余：添加额外的位可以监测出错误位甚至纠正。如在数据中增加checksum等。
时间冗余：执行一个动作，如果需要就再次执行。如事务、超时重传等。
物理冗余：添加额外的设备或进程使系统作为一个整体来容忍部分组件的故障。如HDFS的多备份、HA等等。

### 2.2 高可扩展性
可伸缩性(可扩展性)是一种对软件系统计算处理能力的设计指标，高可伸缩性代表一种弹性，在系统扩展成长过程中，软件能够保证旺盛的生命力，通过很少的改动甚至只是硬件设备的添置，就能实现整个系统处理能力的线性增长，实现高吞吐量和低延迟高性能。

可伸缩性和纯粹性能调优有本质区别， 可伸缩性是高性能、低成本和可维护性等诸多因素的综合考量和平衡，可伸缩性讲究平滑线性的性能提升，更侧重于系统的水平伸缩，通过廉价的服务器实现分布式计算；而普通性能优化只是单台机器的性能指标优化。他们共同点都是根据应用系统特点在吞吐量和延迟之间进行一个侧重选择，当然水平伸缩分区后会带来CAP定理约束。

软件的可扩展性设计非常重要，但又比较难以掌握，业界试图通过云计算或高并发语言等方式节省开发者精力，但是，无论采取什么技术，如果应用系统内部是铁板一块，例如严重依赖数据库，系统达到一定访问规模，负载都集中到一两台数据库服务器上，这时进行分区扩展伸缩就比较困难，正如Hibernate框架创建人Gavin King所说：关系数据库是最不可扩展的。

### 2.3 开放性
可以轻松的与其他平台或系统进行交互，具备与其他系统集成的能力。
如支持异构资源的添加和使用：
提供统一的通信机制，
发布访问共享资源的接口

### 2.4 透明性
在一个分布式系统中，可能包含许许多多的资源，但是对于不同的访问对象，他们的可见性却是不一样的。

例子
一个Http请求的完整处理流程：
DNS获取IP。
入口机器通过Host转发到对应的业务机器。
通过制定URI访问受限的资源。
再提一嘴渣男小明，任一女友问话都能掏心掏肺的回话，但是想查微信，那是万万的不可能，此处的操作手法特别的像分布式服务对外暴露的API。

### 2.5 并发处理能力
分布系统中的各个组成部分可以在并发的过程中被执行。当对同一资源同时进行访问难免会产生冲突。
小明纵是绝世高手还是偶尔还叫错名字。
小明怎么规避这类问题，我一个老实人不太了解。但我在我们的系统中则会用一些互斥和同步的手段来控制资源的并发访问。
如用redis或etcd来模拟分布式锁或用计数器来模拟信号量。e.g. 找到的群红包业务


## 3. 分布式系统的数据一致性
### 3.1 弱一致性、最终一致性
弱一致性并不保证后续访问将返回更新后的值，而最终一致性是弱一致性的一种特定形式。
与强一致性不同，存储系统保证，如果没有对对象进行新的更新，最终所有访问都将返回最后更新的值。
如果发生通信延迟、系统超载、节点崩溃等故障，请求通常会得到一个过期的值。
这种集群方法的优点是保持系统的高可用性和可伸缩性，因为读写可以并发处理，例如社交网络软件上的好友列表和科学日志数据。

### 3.2 强一致性
在分布式系统中，强一致性是一种非常理想的状态，一旦客户机成功地更新了整个系统中任意一个节点中的值，其他客户机在请求这些数据时就不会看到过期的值。
像银行系统这样的实时系统通常需要很强的一致性，因为任何错误的交易都可能导致严重的后果。此外，如果设计者决定保持系统的强一致性，系统的性能将在很大程度上受到影响。


### 3.3 强最终一致性
强最终一致性是最终一致性的一种特殊情况(符合我们上面提到的最终一致性的定义)，它旨在确保错误发生时的活性，但不幸的是，它只适用于某些特定的数据类型和操作。
因此，它可能要求开发人员高度理解那些特定的数据类型。需要注意的是，强最终一致性和最终一致性之间的主要区别是，交付相同更新的正确副本具有相同的副本。
换句话说，一旦一个副本收到来自其他副本的更新，这个副本就会达到一致性，它的状态与源副本完全相同。强最终一致性的优点是，与上面的其他一致方法相比，延迟和通信成本将非常低。
为了实现强最终一致性，Shapiro Marc提出了无冲突复制数据类型(CRDTs)和具有特定同步模式的操作(交换性和收敛性)。

## 4. 分布式服务的架构演进
以阿里后端架构演进为例讲述
https://segmentfault.com/a/1190000018626163